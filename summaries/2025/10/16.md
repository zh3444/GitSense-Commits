# Activity Summary for 10/16/2025

## 4:40:49 PM
The provided log details significant updates to the `Week9.py` file, timestamped 10/16/2025, 3:20:51 PM. This file appears to be the central control script for a Raspberry Pi-based system, managing interactions with both an Android device and an STM microcontroller, alongside capabilities for image capture and remote processing.

Key updates and functionalities include:

*   **System Architecture:** The `RaspberryPi` class acts as the core controller, orchestrating various functionalities. It extensively uses `multiprocessing` for robust Android communication (via `Process`) and `threading` for internal RPI and STM operations (e.g., queue listeners, receive threads), ensuring concurrency and responsiveness.
*   **Communication Links:** The system establishes and manages connections with an Android device using `AndroidLink` and an STM microcontroller via `STMLink`. It includes robust `start`/`stop` mechanisms for these links, along with a `reconnect_android` method for resilience. Shared queues (`Manager.Queue`, `Manager.list`) are heavily utilized for inter-process and inter-thread message passing.
*   **Camera Integration:** Integrates `PiCamera` for image capture, with conditional initialization based on whether the script is running on an actual Raspberry Pi. The `start_camera` and `stop_camera` methods manage its lifecycle.
*   **STM Command Handling:** A `send_and_wait` mechanism ensures reliable communication with the STM, where commands are sent, and the system waits for an acknowledgement (`stm_received` event) within a timeout. The `stm_queue_listener` processes commands sequentially from a shared list.
*   **Android Message Processing:** The `android_io_process` manages the Android connection lifecycle, spawning dedicated threads for sending and receiving messages. Incoming messages (`recv_android`) are parsed from JSON, triggering specific actions like starting arena commands ("sendArena") or requests for image stitching ("stitch-image"), which are then placed into appropriate internal queues. Status updates and action confirmations are sent back to Android via `send_android`.
*   **Image Recognition Workflow (SNAPS Command):** A detailed workflow is implemented for the "SNAPS" command:
    1.  The Raspberry Pi captures an image.
    2.  The captured image is uploaded to an external `IMAGE_SERVER` (whose URL is configured via environment variables) using an HTTP POST request.
    3.  The system processes the server's JSON response, checking for detection status and specific object labels.
    4.  If certain labels are detected (e.g., '38' for a right arrow, '39' for a left arrow), corresponding movement commands (`<RIGHT>`, `<LEFTS>`) are sent to the STM via `send_and_wait`, incorporating retry logic.
    5.  Status updates, including success, detection details, or failures, are continuously sent to the Android device.
    6.  The system tracks obstacles using `self.obstacle_num`.
*   **Synchronization and Error Handling:** The code makes extensive use of `threading.Event` and `multiprocessing.Event` (`stm_done`, `stm_received`, `android_stop_event`, `stm_stop_event`) for precise synchronization and control flow. Comprehensive `try-except` blocks are prevalent across all communication and processing layers, coupled with detailed logging (`self.logger.info`, `self.logger.debug`, `self.logger.error`) for robust error handling and monitoring.
*   **External Configuration:** The system uses `dotenv` to load environment variables, such as `IMAGE_SERVER_URL`, indicating a modular and configurable approach to external service integration.

The file demonstrates a complex, event-driven system designed for autonomous operation, integrating diverse hardware components and external services through robust communication, synchronization, and error management strategies. The consistent pattern of using queues and events for managing concurrent tasks and ensuring sequential command execution is a recurring theme throughout the code.