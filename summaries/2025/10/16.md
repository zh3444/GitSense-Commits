# Activity Summary for 10/16/2025

## 4:40:49 PM
The provided log details significant updates to the `Week9.py` file, timestamped 10/16/2025, 3:20:51 PM. This file appears to be the central control script for a Raspberry Pi-based system, managing interactions with both an Android device and an STM microcontroller, alongside capabilities for image capture and remote processing.

Key updates and functionalities include:

*   **System Architecture:** The `RaspberryPi` class acts as the core controller, orchestrating various functionalities. It extensively uses `multiprocessing` for robust Android communication (via `Process`) and `threading` for internal RPI and STM operations (e.g., queue listeners, receive threads), ensuring concurrency and responsiveness.
*   **Communication Links:** The system establishes and manages connections with an Android device using `AndroidLink` and an STM microcontroller via `STMLink`. It includes robust `start`/`stop` mechanisms for these links, along with a `reconnect_android` method for resilience. Shared queues (`Manager.Queue`, `Manager.list`) are heavily utilized for inter-process and inter-thread message passing.
*   **Camera Integration:** Integrates `PiCamera` for image capture, with conditional initialization based on whether the script is running on an actual Raspberry Pi. The `start_camera` and `stop_camera` methods manage its lifecycle.
*   **STM Command Handling:** A `send_and_wait` mechanism ensures reliable communication with the STM, where commands are sent, and the system waits for an acknowledgement (`stm_received` event) within a timeout. The `stm_queue_listener` processes commands sequentially from a shared list.
*   **Android Message Processing:** The `android_io_process` manages the Android connection lifecycle, spawning dedicated threads for sending and receiving messages. Incoming messages (`recv_android`) are parsed from JSON, triggering specific actions like starting arena commands ("sendArena") or requests for image stitching ("stitch-image"), which are then placed into appropriate internal queues. Status updates and action confirmations are sent back to Android via `send_android`.
*   **Image Recognition Workflow (SNAPS Command):** A detailed workflow is implemented for the "SNAPS" command:
    1.  The Raspberry Pi captures an image.
    2.  The captured image is uploaded to an external `IMAGE_SERVER` (whose URL is configured via environment variables) using an HTTP POST request.
    3.  The system processes the server's JSON response, checking for detection status and specific object labels.
    4.  If certain labels are detected (e.g., '38' for a right arrow, '39' for a left arrow), corresponding movement commands (`<RIGHT>`, `<LEFTS>`) are sent to the STM via `send_and_wait`, incorporating retry logic.
    5.  Status updates, including success, detection details, or failures, are continuously sent to the Android device.
    6.  The system tracks obstacles using `self.obstacle_num`.
*   **Synchronization and Error Handling:** The code makes extensive use of `threading.Event` and `multiprocessing.Event` (`stm_done`, `stm_received`, `android_stop_event`, `stm_stop_event`) for precise synchronization and control flow. Comprehensive `try-except` blocks are prevalent across all communication and processing layers, coupled with detailed logging (`self.logger.info`, `self.logger.debug`, `self.logger.error`) for robust error handling and monitoring.
*   **External Configuration:** The system uses `dotenv` to load environment variables, such as `IMAGE_SERVER_URL`, indicating a modular and configurable approach to external service integration.

The file demonstrates a complex, event-driven system designed for autonomous operation, integrating diverse hardware components and external services through robust communication, synchronization, and error management strategies. The consistent pattern of using queues and events for managing concurrent tasks and ensuring sequential command execution is a recurring theme throughout the code.

## 8:40:49 PM
The `Week8.py` file, last modified on October 16, 2025, at 8:32:50 PM, serves as the core Raspberry Pi server application. This Python script orchestrates various hardware and communication components, centralizing control through the `RaspberryPi` class.

**Key Updates and Functionality:**

*   **Overall Architecture**: The `RaspberryPi` class is designed as a central hub, integrating Android communication (Bluetooth SPP), an STM microcontroller (serial link), camera functionality (PiCamera, with a fallback for non-RPI environments), and external algorithm/image servers (HTTP requests).
*   **Concurrency and Shared State**: The application heavily leverages `multiprocessing.Manager` for creating shared data structures like queues (`android_queue`, `rpi_action_queue`, `stm_queue`, `path_queue`), dictionaries (`current_location`), and lists (`obstacles`, `obstacle_order`) that can be accessed across different processes. `threading.Event` and `threading.Lock` are extensively used for synchronization, particularly for STM communication.
*   **Component Management**: Dedicated `start_` and `stop_` methods are provided for managing the lifecycle of the camera, STM link, and Android communication processes/threads, ensuring proper initialization and cleanup.
*   **Android Communication (`android_io_process`, `recv_android`, `send_android`)**:
    *   A separate process (`android_io_process`) handles the Android connection, spawning threads for sending and receiving messages.
    *   `recv_android` parses incoming JSON messages from Android. It processes `sendArena` commands (to initialize obstacle lists and trigger pathfinding via an algorithm server), `stm` commands (for joystick control of the robot), and `stitch-image` commands.
    *   `send_android` transmits status and other messages back to the Android device from a queue.
    *   Robust reconnection logic (`reconnect_android`) is implemented for the Android link.
*   **STM Communication (`start_stm_link`, `stop_stm_link`, `send_and_wait`)**:
    *   The `STMLink` manages serial communication with the STM microcontroller.
    *   The `send_and_wait` method provides a reliable way to send commands, waiting for explicit "RECEIVED" and "DONE" acknowledgements from the STM within a specified timeout, using `stm_received` and `stm_done` events.
    *   A `movement_lock` prevents multiple threads from sending conflicting commands to the STM.
*   **RPI Action Dispatcher (`rpi_queue_listener`)**: This listener thread processes `PiAction` objects from the `rpi_action_queue`.
    *   "control" actions (e.g., joystick commands) are enqueued directly into the `stm_queue` for eventual execution by the STM.
    *   "obstacle" actions (received from `sendArena` via Android) trigger an HTTP POST request to an `ALGO_SERVER`'s `/path` endpoint to obtain navigation commands, which are then put into `path_queue`.
*   **Configuration**: Environment variables `IMAGE_SERVER_URL` and `ALGO_SERVER_URL` are loaded from a `.env` file, indicating flexible server configuration.
*   **New Data Structure**: A `PiAction` class is introduced as a simple structure to encapsulate action categories and their values, streamlining command handling.

**Patterns and Recurring Elements:**

*   **Queue-centric Communication**: Most internal communication between different threads and processes relies on `multiprocessing.Queue` or `multiprocessing.Manager().Queue()` instances.
*   **Event-driven Synchronization**: `threading.Event` objects are frequently used to signal completion, reception, or stop conditions across threads.
*   **Modular Start/Stop**: A consistent pattern of `start_` and `stop_` methods for each major component ensures controlled resource management.
*   **Error Handling and Logging**: Extensive `try-except` blocks with `self.logger.info`, `self.logger.debug`, and `self.logger.error` calls are used throughout for robust operation and debugging.
*   **Conditional RPI Functionality**: The code checks `IS_RPI` to conditionally initialize PiCamera components, making it adaptable to different development environments.

**Missing Information (within the provided log snippet):**
The implementation for the `stm_queue_listener` method, which is intended to run as a thread, is not provided. Similarly, the `check_api()` method called within `android_io_process()` is not defined in this snippet.