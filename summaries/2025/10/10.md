# Activity Summary for 10/10/2025

## 12:40:28 AM
The log primarily details a series of changes to the `c:\Users\zhiha\MDP_Shared\MDP-Maxxing\RPI_Server\Week8.py` file, all occurring on October 9, 2025.

**File-Specific Updates (`Week8.py`):**

*   **Early Morning (8:28:05 AM):** The `RaspberryPi` class was established with initial functionalities for managing Android and STM communication, camera operations, and queue-based task processing. The `send_and_wait` method was present, designed to send commands to the STM and wait for a "DONE" signal using `self.stm_done`.
*   **Mid-Morning (8:45:17 AM - 8:52:19 AM):**
    *   The `send_and_wait` method's signature was temporarily altered to include a `curr_time` parameter, suggesting an attempt to integrate time-based tracking for commands. This parameter was later removed (8:50:48 AM, confirmed by 8:52:19 AM).
    *   A significant addition was the introduction of `self.stm_received = threading.Event()` (8:47:18 AM), intended to track when the STM has acknowledged receiving a command.
    *   The `send_and_wait` method was then iteratively updated (8:50:48 AM, 8:51:03 AM, 8:51:25 AM) to incorporate waiting for `self.stm_received` *before* waiting for `self.stm_done`, enhancing the robustness of command transmission by ensuring receipt confirmation.
*   **Late Morning (8:52:36 AM - 9:50:44 AM):**
    *   The logic within `send_and_wait` was refined to include an *early return* (`return received`) if the `stm_received` event times out (8:52:36 AM), making command acknowledgment a critical success condition.
    *   The timeout duration for `stm_received.wait()` was specifically adjusted, first to a fixed `2.0` seconds (8:54:28 AM), then briefly commented out (8:54:39 AM), before being re-enabled with the `2.0` second timeout (8:57:18 AM).
    *   The timeout for `stm_received.wait()` was increased to `5.0` seconds (9:27:22 AM), providing more leeway for the STM to acknowledge commands.
    *   A conditional check, `if cmd != "<FIN>":`, was introduced (9:50:44 AM) around the `stm_received` waiting logic. This change indicates that the RPI will skip waiting for a "received" acknowledgment specifically for the "FIN" command, suggesting it might be a special termination command that doesn't require immediate confirmation.

**Timestamps of Significant Changes:**

*   **10/9/2025, 8:45:17 AM:** Addition of `curr_time` parameter (later removed).
*   **10/9/2025, 8:47:18 AM:** Introduction of `self.stm_received` event.
*   **10/9/2025, 8:50:48 AM:** `send_and_wait` starts clearing and waiting for `self.stm_received`. `curr_time` removed.
*   **10/9/2025, 8:52:36 AM:** Implemented early return on `stm_received` timeout.
*   **10/9/2025, 8:54:28 AM:** `stm_received` timeout fixed to `2.0` seconds.
*   **10/9/2025, 8:54:39 AM:** Temporary rollback/comment-out of `stm_received` wait.
*   **10/9/2025, 8:57:18 AM:** `stm_received` wait restored with `2.0` second timeout.
*   **10/9/2025, 9:27:22 AM:** `stm_received` timeout adjusted to `5.0` seconds.
*   **10/9/2025, 9:50:44 AM:** `stm_received` wait made conditional on the command not being "<FIN>".

**Patterns and Recurring Elements:**

*   **Refinement of STM Communication Protocol:** A clear pattern of iteratively enhancing the reliability of command-and-control communication with the STM is observed. This is evidenced by the introduction of a new synchronization event (`self.stm_received`) and the continuous adjustments to the `send_and_wait` method's logic and timeout values.
*   **Event-Driven Synchronization:** The consistent use of `threading.Event` (`stm_done`, `stm_received`) highlights an event-driven approach to synchronize between the RPI and STM, crucial for managing asynchronous hardware interactions in a multi-threaded environment.
*   **Timeout Management:** There's a recurring focus on defining and adjusting timeouts for critical operations, reflecting an effort to balance responsiveness with robustness against unresponsive hardware or network conditions.
*   **Debugging and Iteration:** The brief addition and removal of parameters, and the commenting/uncommenting of code blocks, suggest an active development and debugging process to find the optimal communication strategy.
*   **Modular Design:** The `RaspberryPi` class is designed to manage various hardware and software components (camera, STM, Android link, Algo server) using queues and dedicated listener threads, demonstrating a modular and concurrent architecture.