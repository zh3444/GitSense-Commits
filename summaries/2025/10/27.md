# Activity Summary for 10/27/2025

## 9:42:46 AM
The provided log details changes to two distinct Dockerfiles, both updated on October 27, 2025.

**File-Specific Updates:**

*   **`/Users/zhihao/Desktop/NTU/SC3010/log4j-shell-poc/Dockerfile`**:
    *   This Dockerfile, first recorded at 8:57:59 AM, defines an image based on `tomcat:8.5-jre8`. It is configured to deploy a `log4shell-1.0-SNAPSHOT.war` file as the root web application, exposes port 8080, and starts Tomcat using `catalina.sh`. An earlier commented-out line indicates a potential prior use of `tomcat:8.0.36-jre8`. This appears to be setting up an environment for a Log4j shell exploit proof-of-concept.

*   **`/Users/zhihao/Desktop/NTU/SC3010/log4j-test/Dockerfile`**:
    *   This Dockerfile, with its initial content recorded at 9:39:10 AM and an identical subsequent entry at 9:39:55 AM, employs a multi-stage build process for a Java application.
        *   The first stage, named `builder`, uses `maven:3.8.8-openjdk-8` to compile the `pom.xml` and `src` directory into a `log4j-test-1.0.jar`.
        *   The second stage uses `eclipse-temurin:8-jre` as its base, copies the compiled JAR from the builder stage, exposes port 8080, and executes the Java application with `java -jar /app/app.jar`. This Dockerfile seems dedicated to building and running a test application related to Log4j.

**Timestamps of Significant Changes:**

All changes occurred on October 27, 2025. The `log4j-shell-poc` Dockerfile was updated at 8:57:59 AM. The `log4j-test` Dockerfile saw its content first introduced at 9:39:10 AM, with an identical save or minor unlogged change recorded at 9:39:55 AM, suggesting a period of active work within the hour.

**Patterns and Recurring Elements:**

*   **Log4j Focus:** Both projects (`log4j-shell-poc` and `log4j-test`) are explicitly named in a way that indicates a direct relation to the Log4j vulnerability, either for exploitation demonstration or testing purposes.
*   **Docker Containerization:** All entries involve `Dockerfile`s, highlighting a consistent approach to containerizing these applications using Docker.
*   **Java Applications:** Both setups are for Java-based applications, one deploying a WAR to Tomcat and the other building and running a JAR directly.
*   **Port Exposure:** Both Dockerfiles expose port 8080, which is a common default port for web servers and Java applications.
*   **Focused Development:** All timestamps fall on the same day, suggesting a concentrated development effort on Log4j-related Docker configurations.

## 10:42:51 AM
The provided log details changes across two distinct projects related to Log4j: `log4j-shell-poc` and `log4j-test`. All recorded modifications occurred on `10/27/2025`, indicating active development or setup within a short timeframe.

**Key Changes by File:**

*   **`/Users/zhihao/Desktop/NTU/SC3010/log4j-shell-poc/Dockerfile`**
    *   **Timestamp:** `10/27/2025, 8:57:59 AM`
    *   **Description:** This Dockerfile sets up a Tomcat 8.5-jre8 container. It removes default web applications and deploys `log4shell-1.0-SNAPSHOT.war` as the ROOT application. Port 8080 is exposed, and Tomcat is started via `catalina.sh`. An older `FROM tomcat:8.0.36-jre8` instruction is commented out.

*   **`/Users/zhihao/Desktop/NTU/SC3010/log4j-test/Dockerfile`**
    *   **Timestamps:** `10/27/2025, 9:39:10 AM`, `10/27/2025, 9:39:55 AM`, `10/27/2025, 9:47:08 AM`
    *   **Description:** This Dockerfile underwent several iterations within a few minutes.
        *   The initial versions (`9:39:10 AM` and `9:39:55 AM`, which are identical) implemented a multi-stage build. It used `maven:3.8.8-openjdk-8` to build a Java application (`log4j-test-1.0.jar`) and then copied this artifact into a smaller `eclipse-temurin:8-jre` image.
        *   A later change at `9:47:08 AM` simplified the Dockerfile to a single-stage build. This version directly used `eclipse-temurin:8-jre` and copied an already compiled `log4j-test-1.0.jar` into the image, implying the build step is expected to happen externally or in a prior process not shown.
        *   Across all versions, the Dockerfile consistently exposes port 8080 and specifies `java -jar /app/app.jar` as the command to run the application.

*   **`/Users/zhihao/Desktop/NTU/SC3010/log4j-test/src/main/java/local/log4j/ExampleServer.java`**
    *   **Timestamp:** `10/27/2025, 10:21:58 AM`
    *   **Description:** This Java source file defines an `ExampleServer` that implements a minimal HTTP server. Its primary function, as noted in the comments, is to explicitly log the value of the "X-Api-Version" HTTP header using `org.apache.logging.log4j.Logger.info()`. This is highlighted as the "important logging call that will trigger Log4j lookups," indicating its role in testing Log4j behavior, likely related to known vulnerabilities. The server handles GET and HEAD requests on port 8080, returning "OK\n" for GET and only headers for HEAD. It includes a cautionary note about running it only in a controlled, local test environment.

**Patterns and Recurring Elements:**

*   **Log4j Testing Focus:** Both projects (`log4j-shell-poc` and `log4j-test`) are explicitly named and designed for purposes related to Log4j, strongly suggesting testing or demonstration of Log4j vulnerabilities (like shell exploits or lookup evaluation).
*   **Containerization with Docker:** All applications are packaged and managed using Dockerfiles, indicating a preference for isolated and reproducible test environments.
*   **Java 8 Environment:** The projects consistently target Java 8 (JRE 8, OpenJDK 8, eclipse-temurin:8-jre), which is common for Log4j vulnerability contexts.
*   **Port 8080 Exposure:** Both Dockerfiles consistently expose port 8080, indicating that the applications are designed to be accessed via HTTP on this standard port.
*   **HTTP Server Functionality:** The `ExampleServer.java` code explicitly creates an HTTP server, reinforcing that the testing involves HTTP interactions to trigger Log4j logging.
*   **Rapid Iteration:** The multiple timestamps for the `log4j-test/Dockerfile` within a short period suggest rapid development or troubleshooting of the build process.