# Activity Summary for 10/15/2025

## 2:53:24 PM
The changes primarily focus on the `Week9.py` file within the `c:\Users\zhiha\MDP_Shared\MDP-Maxxing\RPI_Server\` directory, occurring in a rapid sequence between 2:28:23 PM and 2:34:30 PM on October 15, 2025.

**File-Specific Updates (`Week9.py`):**

The core of the modifications revolves around the `send_and_wait` method and how its return value is handled in the `stm_queue_listener`.

1.  **Initial `send_and_wait` (10/15/2025, 2:28:23 PM):**
    *   The `send_and_wait` function was largely a send-and-forget mechanism. Both the `self.stm_received.wait(timeout)` and `self.stm_done.wait(timeout)` calls were commented out, causing the function to always return `True` after attempting to send the command to the STM, regardless of reception acknowledgment or completion status.

2.  **Re-enabling "RECEIVED" Acknowledgment (10/15/2025, 2:29:33 PM):**
    *   The `self.stm_received.wait(timeout)` check was uncommented. This made `send_and_wait` wait for an acknowledgment that the STM received the command. If no acknowledgment was received within the timeout, a debug message was logged, and the function would return the result of `stm_received.wait(timeout)` (which would be `False`). The `self.stm_done.wait(timeout)` remained commented.

3.  **Attempted Resend Logic in `send_and_wait` (10/15/2025, 2:31:39 PM - 2:32:13 PM):**
    *   An initial attempt was made to implement a resend mechanism directly within the `send_and_wait` function. If `stm_received.wait` timed out, a log message `Resending {cmd} to STM` was added (2:31:39 PM).
    *   Shortly after, an actual recursive call `self.send_and_wait(cmd)` was added after the log message, meaning the function would try to resend the command if the initial "RECEIVED" acknowledgment failed (2:32:13 PM).

4.  **Reversion of `send_and_wait` Resend (10/15/2025, 2:32:28 PM):**
    *   The explicit resend logic (`self.logger.info` and `self.send_and_wait(cmd)`) within `send_and_wait` was commented out, reverting the function to its state of simply waiting once for "RECEIVED" acknowledgment and returning `True` or `False` based on that single attempt.

5.  **Caller-Side Resend for Critical Commands (10/15/2025, 2:33:59 PM - 2:34:30 PM):**
    *   The logic for handling "SNAPS" commands within the `stm_queue_listener` was modified. Specifically, when image recognition detected '38' (right arrow) or '39' (left arrow), the `self.send_and_wait` calls for `<RIGHT>` and `<LEFTS>` commands were wrapped in `while not received:` loops. This change implements a retry mechanism at the *caller* level, ensuring that these critical movement commands are repeatedly sent to the STM until `send_and_wait` successfully receives an acknowledgment (returns `True`). This pattern persists in the final logged entries.

**Patterns and Recurring Elements:**

*   **Iterative Refinement of Communication Reliability:** The log demonstrates a continuous effort to improve the robustness of command transmission from the Raspberry Pi to the STM. This is evident through the repeated commenting, uncommenting, and restructuring of the `send_and_wait` function's retry logic.
*   **Decoupling Retry Logic:** The evolution shows a shift from attempting to embed comprehensive retry logic within the `send_and_wait` function itself to moving that specific retry logic to the calling function (`stm_queue_listener`) for critical commands (like movement commands derived from image recognition). This suggests a design decision to make `send_and_wait` a single-attempt acknowledged sender, with specific callers responsible for their own retry policies.
*   **Consistent Logging:** The code consistently uses `self.logger.debug` and `self.logger.info` for tracking communication status, errors, and actions, which is helpful for debugging the complex multi-threaded and multi-process architecture.
*   **No changes to `load_dotenv()` or direct key exposure:** The usage of `load_dotenv()` for environment variables is noted, but no actual `.env` file content or direct key information is present in the provided log entries.
*   **Stable Infrastructure:** Throughout these changes, the overall `RaspberryPi` class structure, its initialized components (AndroidLink, STMLink, queues, camera setup), and the high-level start/stop methods remain consistent, indicating that the foundational architecture was stable while the communication handshake logic was being fine-tuned.

## 3:53:21 PM
The `c:\Users\zhiha\MDP_Shared\MDP-Maxxing\RPI_Server\Week9.py` file, last modified on `10/15/2025, 3:34:05 PM`, defines a comprehensive `RaspberryPi` control system. This system integrates communication with an Android device, a Microcontroller (STM), and an external image processing server, while managing a camera for image capture.

Key updates and functionalities include:

*   **Core RaspberryPi Class:** The `RaspberryPi` class orchestrates all operations, utilizing `multiprocessing.Manager` for shared queues and lists (`android_queue`, `rpi_action_queue`, `stm_queue`, `obstacles`) and `threading.Event`/`multiprocessing.Event` for synchronization between threads and processes.
*   **Hardware Management:** It includes methods to `start` and `stop` a PiCamera (conditionally, based on `IS_RPI` flag), and establish/disconnect serial communication with an STM via `STMLink`. Camera resolution is set to 640x640.
*   **Android Communication:** A dedicated `android_io_process` runs in a separate process to handle Bluetooth communication with Android. It includes threads for sending (`send_android`) and receiving (`recv_android`) messages. The system sends status updates (e.g., "ready-to-roll", "API returned non 200 status") to Android and processes commands like `sendArena` (triggering "<START>" for STM) and `stitch-image`. Robust reconnection logic for Android is also implemented.
*   **STM Communication and Control:** The `stm_link` handles communication with the STM. The `send_and_wait` method sends commands to the STM and waits for an acknowledgment, incorporating timeouts and retries. The `stm_queue_listener` processes commands for the STM.
*   **Image Capture and Processing Workflow:** A significant feature is the handling of "SNAPS" commands for obstacle recognition.
    *   The system takes a snapshot using `take_snapshot()` (implied method).
    *   If successful, the image is uploaded to an `IMAGE_SERVER` (URL loaded from environment variables using `dotenv`).
    *   The server's response is processed: if an annotated image indicates a '38' (right arrow) or '39' (left arrow) label, the corresponding "<RIGHT>" or "<LEFTS>" command is sent to the STM.
    *   Failures in snapshot capture or image upload result in status updates to Android and retries of the "SNAPS" command.
*   **Queue Listeners:** `rpi_queue_listener` processes general RPI actions, forwarding control commands to the STM queue or triggering image stitching. `stm_queue_listener` specifically handles commands destined for the STM, including the complex image capture/upload/response logic for "SNAPS."
*   **Environment Configuration:** The system uses `dotenv` to load environment variables, specifically for the `IMAGE_SERVER_URL`, indicating reliance on external configuration.

Overall, the code outlines a robust, multi-threaded, and multi-process control application for a Raspberry Pi, focusing on integrated communication, hardware control, and an intelligent image-based decision-making pipeline.