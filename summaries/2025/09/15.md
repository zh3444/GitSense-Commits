# Activity Summary for 9/15/2025

## 11:16:39 AM
The code logs show development of a Raspberry Pi server for a robotics application, focusing on communication with Android and potentially an STM32 device.

**`link.py` (9/15/2025, 10:26 AM & 10:27 AM):** This file defines an abstract base class `Link` for communication, with methods `send` and `recv`.  The second revision adds an `__init__` method initializing a logger.  This suggests a refactoring to incorporate logging consistently.

**`spp_server.py` (9/15/2025, 10:31 AM - 10:51 AM):** This file implements a Bluetooth Serial Port Profile (SPP) server using the `bluetooth` library.  The `AndroidLink` class handles connection, sending (`send`), and receiving (`recv`) messages using a custom `AndroidMessage` class for structured data.  The initial version uses `print` statements for logging.  Subsequent revisions (10:34 AM and 10:35 AM) replace `print` statements with calls to `self.logger.info` and `self.logger.error`, indicating the integration of logging functionality. The final revision (10:51 AM) removed the commented out `logger` import.

**`Week8.py` (9/15/2025, 11:04 AM):** This file is the main Raspberry Pi application. It uses multiprocessing and threading for concurrent tasks:

*   **Android Communication:** Manages communication with an Android device using the `AndroidLink` from `spp_server.py`. It utilizes threads for sending and receiving messages concurrently.  Error handling is present to manage connection drops and invalid messages.  Includes a `reconnect_android` function for robust connection management. A test function (`test_android`) sends random messages to the Android device for testing purposes.
*   **RPI Action Queue:** The `rpi_action_queue` processes commands, such as obstacle information (`sendArena`) and control commands (`stm`) from the Android app.
*   **Multiprocessing:** Uses multiple processes (`android_listener`, etc.) to handle different aspects of the system. A `rpi_queue_process` function is designed to handle commands from the RPI queue.

Recurring elements across the log include error handling (`try...except` blocks) and logging improvements (switching from `print` to logger functions). The overall structure is evolving from a basic implementation to a more robust and structured application using multiprocessing and improved logging.


## 12:16:38 PM
The Python script `Week8.py` implements a Raspberry Pi server for coordinating actions between an Android device, an STM32 microcontroller (STM), and a robot.  The code uses multiprocessing and threading extensively.  Key features include:

* **Inter-process Communication (IPC):**  `Manager` objects from the `multiprocessing` library are used to create shared queues (`android_queue`, `rpi_action_queue`, `stm_queue`, `path_queue`) for communication between processes.  `Event` objects (`android_stop_event`) handle process synchronization.

* **Android Communication:** An `AndroidLink` class manages communication with an Android device.  A dedicated process (`android_io_process`) handles both sending and receiving messages using separate threads (`send_android`, `recv_android`).  The `recv_android` thread parses JSON messages from Android, identifying message categories (`'sendArena'`, `'stm'`) to trigger appropriate actions.  A `reconnect_android` function handles reconnection attempts.  A temporary `test_android` function sends test messages to the Android queue.

* **Action Handling:**  The `PiAction` class represents actions, categorized by type (`info`, `error`, `location`, `image rec`, `status`, `obstacle`, `control`). A `rpi_queue_process` function processes actions from the `rpi_action_queue`.

* **Robot Control:** The code includes placeholders for STM32 integration and algorithm endpoints (marked with `TODO`).  A `movement_lock` is used for thread safety when updating robot location.  Obstacle handling is partially implemented, using shared dictionaries (`obstacles`, `success_obstacles_list`, `failed_obstacles_list`).

* **Logging:** The `prepare_logger` function (from an external `logger` module) is used for logging.

The code is heavily reliant on asynchronous operations and error handling (e.g., `try...except` blocks for network issues and JSON parsing).  A significant portion of the code is marked with `TODO`, indicating incomplete integration with STM32, algorithm endpoints, and full obstacle handling.  The timestamp of the log entry is September 15th, 2025, at 12:10:25 PM.


## 1:16:44 PM
The log shows a series of modifications to `Week8.py`, focusing on image capture and processing, and communication with Android and a server.

Initially (`9/15/2025, 12:20:15 PM`), the code established a basic framework for multi-process communication between a Raspberry Pi, an Android device, and an external server. It included  placeholder functions and a basic `PiAction` class for managing actions.  The Android communication involved sending and receiving JSON messages.  A testing function (`test_android`) randomly sent messages to simulate Android interaction.


The second change (`9/15/2025, 12:25:51 PM`) added `numpy` for image array manipulation. A `take_snapshot` function was introduced to capture images using the PiCamera, converting them into numpy arrays.

The third modification (`9/15/2025, 12:29:44 PM`) incorporated `cv2` (OpenCV) for image encoding and `pathlib` for file path handling. The `take_snapshot` function was enhanced to convert the raw image to a JPEG, and save it locally.


In the fourth update (`9/15/2025, 12:39:55 PM`), the image saving process was improved to use a temporary file to prevent data loss during file writing.  The function now returns a JPEG stream in a BytesIO object instead of a file path.

The fifth update (`9/15/2025, 12:48:20 PM`) integrated image upload to a server using the `requests` library. The `take_snapshot` function's return value is used to send captured images to the server.  Success or failure of the upload is logged, and a message is sent to Android about successful image upload.


The sixth and seventh updates (`9/15/2025, 12:55:27 PM` and `9/15/2025, 12:59:22 PM`), refine the image-rec message sent to Android,  including obstacle ID, x, y, and d coordinates received from the server response. This improves data flow between the Pi, server, and Android.  The `test_android` function was modified to trigger image capture via the `rpi_action_queue`.

The final two changes (`9/15/2025, 1:02:21 PM` and `9/15/2025, 1:07:56 PM`) started the `rpi_queue_process` as a separate process instead of within the main thread. This enhances the overall responsiveness of the system by allowing concurrent processing of tasks.  Minor typographical errors and inconsistencies in function calls were corrected in the last two commits.

The  `server_receive_image.py` file shows a server endpoint for receiving and processing images, performing object detection using a loaded model, and returning the annotation information. This server interacts with the Raspberry Pi's `Week8.py` script.  The server saves original images and annotated images into separate folders.

In summary, the code evolved from a basic framework to a robust system for capturing, processing, and uploading images from a Raspberry Pi to a server, along with refined communication to an Android device.  The use of multiprocessing improved system efficiency.  The most significant changes involved image saving, server integration, and proper multi-processing handling.
