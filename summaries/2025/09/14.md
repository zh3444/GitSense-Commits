# Activity Summary for 9/14/2025

## 2:05:10 PM
The log shows three revisions of the file `c:\Users\zhiha\MDP_Shared\MDP-Maxxing\RPI_Server\communication\spp_server.py` within a short time frame (approximately 20 minutes on September 14, 2025).  The core functionality remains consistent throughout all revisions: establishing a Bluetooth Serial Port Profile (SPP) server connection with an Android device, sending and receiving JSON-formatted messages.

The key changes are related to logging:

* **Initial Version (1:03:17 PM):**  Print statements are used for logging connection status and error handling.
* **Second Revision (1:03:57 PM):**  The `AndroidMessage` class is modified to include a logger instance (`self.logger = prepare_logger()`), and all print statements are replaced with calls to the logger for both informational and error messages.  This is a significant improvement for debugging and monitoring.
* **Third Revision (1:04:30 PM):** The logger instantiation is moved from the `AndroidMessage` class to the `AndroidLink` class.  This is a minor change, logically placing the logger with the class responsible for the Bluetooth connection.

No other significant code changes are observed across the three versions.  The Bluetooth connection setup, message handling (sending and receiving), and error handling remain largely the same. The pattern shows a progressive improvement in the code's logging mechanism, replacing basic print statements with a more robust logging framework.


## 3:05:10 PM
The code implements a Raspberry Pi server (`Week8.py`) that communicates with an Android device and potentially an STM32 microcontroller (though STM32 integration is noted as TODO).  The communication with the Android device uses Bluetooth SPP (`spp_server.py`).

`spp_server.py` (updated 9/14/2025, 2:07:16 PM) defines classes for handling Bluetooth communication: `AndroidMessage` for structuring messages and `AndroidLink` for establishing and managing the Bluetooth connection.  `AndroidLink` includes methods for connecting, disconnecting, sending, and receiving JSON-formatted messages.  The code uses the `bluetooth` library and includes error handling for connection and communication issues.  The SPP UUID is defined as "94f39d29-7d6d-437d-973b-fba39e49d4ee".

`Week8.py` (updated 9/14/2025, 3:03:15 PM) is the main program, setting up a multi-process architecture using `multiprocessing`.  It uses `AndroidLink` from `spp_server.py` to communicate with Android.  The code manages queues for sending and receiving messages to/from Android and (planned) STM32.  The `android_io_process` function handles the Bluetooth connection and spawns threads for sending (`send_android`) and receiving (`recv_android`) messages.  Message handling includes parsing JSON data and routing commands based on message category ('sendArena' for obstacle data, 'stm' for robot control).  A `test_android` function simulates sending various test messages to Android.  The code also incorporates error handling, logging (`logger` module), and a reconnection mechanism (`reconnect_android`).  The use of `Manager` suggests shared memory is used for inter-process communication.  The program defines classes for managing actions (`PiAction`) and the overall Raspberry Pi state (`RaspberryPi`).  There is a significant amount of error handling throughout the code.  The program starts by initializing these processes and the main loop remains in listening mode.


## 4:05:10 PM
The log shows multiple revisions of the `Week8.py` file, all on September 14th, 2025.  The core functionality remains consistent across all revisions:  the script establishes communication between a Raspberry Pi and an Android device, handling message exchanges and executing actions based on received commands.  The Raspberry Pi utilizes multiprocessing (processes and threads) to manage tasks concurrently, using queues for inter-process communication.

The primary changes across revisions seem to be minor bug fixes and refinements rather than large-scale structural alterations.  Specifically:

* **Revision 1 (3:26:37 PM):** This version includes comprehensive error handling within the `recv_android` function, addressing potential `OSError` exceptions during reception and `json.JSONDecodeError` during JSON parsing.  The `recv_android` function also checks if the incoming message is a dictionary before further processing.  A `test_android` function is present for testing purposes, simulating different message types to the Android queue.  The code contains several TODOs related to STM32 integration and algorithm endpoint calls.

* **Revision 2 (3:26:58 PM):** This revision is identical to revision 1.  The timestamp suggests a possible accidental re-save or a very minor, undetectable edit.


* **Revision 3 (3:30:38 PM):** The only noticeable difference from the previous versions is a simplification in the `recv_android` function.  A check for `msg_str[0] in "{["` before `json.loads` has been removed. This suggests a potential fix related to message format handling.  The rest of the code remains unchanged.


In all versions, the code uses `AndroidMessage` objects to represent messages, categorized by types like `image-rec`, `location`, `control`, and `obstacle`.  The code manages queues (`android_queue`, `rpi_action_queue`, `stm_queue`, `path_queue`), events (`android_stop_event`), and locks (`movement_lock`) for synchronization and efficient task execution.  The use of a `prepare_logger` function indicates a structured logging system in place.  The `reconnect_android` function implements automatic reconnection logic for maintaining the Android connection.  The recurring TODOs highlight areas of planned future development.
